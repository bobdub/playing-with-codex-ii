<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Codex II Chat Garden</title>
    <style>
      :root {
        color-scheme: light dark;
        --surface: rgba(255, 255, 255, 0.82);
        --surface-dark: rgba(12, 17, 27, 0.82);
        --border: rgba(86, 93, 110, 0.4);
        --accent: #6c5ce7;
        --accent-dark: #a29bfe;
        --text-strong: #0f172a;
        --text-muted: #475569;
        --shadow: 0 20px 45px rgba(15, 23, 42, 0.2);
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: linear-gradient(130deg, #060b23 0%, #111b45 40%, #1f1033 100%);
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        color: var(--text-strong);
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at 15% 20%, rgba(108, 92, 231, 0.35), transparent 55%),
          radial-gradient(circle at 85% 15%, rgba(162, 155, 254, 0.25), transparent 55%),
          radial-gradient(circle at 40% 85%, rgba(76, 201, 240, 0.18), transparent 60%);
        filter: blur(35px);
        z-index: 0;
      }

      .app-shell {
        position: relative;
        z-index: 1;
        margin: 2.5rem auto;
        width: min(1100px, 95vw);
        background: color-mix(in srgb, var(--surface) 70%, #f8fafc 30%);
        backdrop-filter: blur(24px);
        border-radius: 32px;
        border: 1px solid color-mix(in srgb, var(--border) 70%, rgba(255, 255, 255, 0.35) 30%);
        box-shadow: var(--shadow);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      header {
        padding: 2.5rem clamp(2rem, 5vw, 3rem) 1.5rem;
        background: linear-gradient(160deg, rgba(108, 92, 231, 0.15), rgba(15, 23, 42, 0.4));
        color: #f8fafc;
      }

      header h1 {
        margin: 0;
        font-size: clamp(2rem, 4vw, 2.8rem);
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      header p {
        margin: 0.75rem 0 0;
        max-width: 60ch;
        color: rgba(241, 245, 249, 0.88);
        font-size: 1rem;
        line-height: 1.6;
      }

      main {
        display: grid;
        grid-template-columns: minmax(0, 2fr) minmax(280px, 1fr);
        gap: 1px;
        background: rgba(148, 163, 184, 0.35);
      }

      .panel {
        background: rgba(248, 250, 252, 0.92);
        padding: clamp(1.75rem, 4vw, 2.5rem);
        min-height: 420px;
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }

        .panel {
          padding: clamp(1.5rem, 4vw, 2.25rem);
        }
      }

      .chat-panel {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .messages {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        max-height: clamp(320px, 45vh, 520px);
        overflow-y: auto;
        padding-right: 0.25rem;
      }

      .message {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 0.75rem;
        align-items: flex-start;
        border-radius: 18px;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(226, 232, 240, 0.7);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.08);
        backdrop-filter: blur(20px);
        animation: fadeUp 180ms ease-in both;
      }

      .message.bot {
        background: rgba(108, 92, 231, 0.09);
        border-color: rgba(108, 92, 231, 0.35);
      }

      .message.user {
        background: rgba(76, 201, 240, 0.1);
        border-color: rgba(76, 201, 240, 0.35);
      }

      .message.system {
        background: rgba(248, 250, 252, 0.85);
        border-style: dashed;
      }

      .message__role {
        font-weight: 600;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .message__body {
        margin: 0;
        font-size: 0.98rem;
        line-height: 1.6;
        color: var(--text-strong);
      }

      @keyframes fadeUp {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      form.chat-composer {
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.85);
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        padding: 0.5rem;
        gap: 0.75rem;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
      }

      form.chat-composer textarea {
        resize: vertical;
        min-height: 72px;
        max-height: 220px;
        border: none;
        padding: 0.75rem 1rem;
        font: inherit;
        background: transparent;
        color: inherit;
      }

      form.chat-composer textarea:focus {
        outline: none;
      }

      button.primary {
        border: none;
        border-radius: 16px;
        padding: 0.85rem 1.8rem;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        color: #f8fafc;
        background: linear-gradient(140deg, var(--accent), #4cc9f0);
        transition: filter 150ms ease, transform 150ms ease;
      }

      button.primary:disabled {
        opacity: 0.65;
        cursor: progress;
      }

      button.primary:hover:not(:disabled) {
        filter: brightness(1.05);
        transform: translateY(-1px);
      }

      .persona-panel {
        display: grid;
        gap: 1rem;
      }

      .persona-panel h2 {
        margin: 0;
        font-size: 1.3rem;
      }

      .persona-panel p.description {
        margin: 0;
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      .persona-panel textarea {
        width: 100%;
        min-height: 180px;
        resize: vertical;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        padding: 1rem;
        font: inherit;
        background: rgba(255, 255, 255, 0.9);
        line-height: 1.5;
      }

      .persona-panel .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .persona-panel button.secondary {
        border: 1px solid rgba(108, 92, 231, 0.4);
        border-radius: 14px;
        background: transparent;
        color: var(--accent);
        font-weight: 600;
        padding: 0.65rem 1.4rem;
        cursor: pointer;
        transition: background 150ms ease, color 150ms ease;
      }

      .persona-panel button.secondary:hover {
        background: rgba(108, 92, 231, 0.12);
        color: var(--accent-dark);
      }

      .persona-panel .hint {
        background: rgba(15, 23, 42, 0.05);
        border-radius: 14px;
        padding: 0.85rem 1rem;
        font-size: 0.88rem;
        line-height: 1.5;
        color: var(--text-muted);
      }

      footer {
        padding: 1rem 2rem 2rem;
        color: rgba(226, 232, 240, 0.75);
        font-size: 0.85rem;
        text-align: center;
      }

      footer a {
        color: inherit;
      }

      .spinner {
        width: 16px;
        height: 16px;
        border-radius: 999px;
        border: 2px solid rgba(108, 92, 231, 0.2);
        border-top-color: rgba(108, 92, 231, 0.8);
        animation: spin 700ms linear infinite;
        margin-top: 0.25rem;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      ::placeholder {
        color: rgba(148, 163, 184, 0.8);
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <h1>Codex II: Local-first Chat Garden</h1>
        <p>
          Welcome, caretaker. Spin up your favourite local LLM and connect through a
          simple endpoint&mdash;no public keys, no managed secrets. This interface keeps
          the conversation grounded in your own machine while celebrating a personality you can shape.
        </p>
      </header>
      <main>
        <section class="panel chat-panel" aria-label="Chat conversation">
          <div class="messages" id="messages" role="log" aria-live="polite"></div>
          <form id="chat-form" class="chat-composer" autocomplete="off">
            <label class="sr-only" for="chat-input">Your message</label>
            <textarea
              id="chat-input"
              name="prompt"
              placeholder="Share your question or story..."
              required
            ></textarea>
            <button id="send-button" class="primary" type="submit">Send</button>
          </form>
        </section>
        <aside class="panel persona-panel" aria-label="Persona controls">
          <div>
            <h2>Bot personality</h2>
            <p class="description">
              Craft the system prompt that shapes your companion. Changes are stored locally so you can iterate without losing your favorite tone.
            </p>
          </div>
          <label for="persona-input" class="sr-only">Persona prompt</label>
          <textarea id="persona-input"></textarea>
          <div class="actions">
            <button id="save-persona" class="primary" type="button">Save persona</button>
            <button id="reset-persona" class="secondary" type="button">Reset to default</button>
          </div>
          <div class="hint">
            Point a lightweight HTTP server to <code>/api/chat</code> and send JSON shaped like
            <code>{ message, history, persona }</code>. The UI will display the reply immediately when received and fall back to an
            offline note if the endpoint is unreachable.
          </div>
        </aside>
      </main>
      <footer>
        <strong>Status tip:</strong> Run a local process that accepts <code>POST /api/chat</code> to bring the garden to life.
        You control storage, prompts, and privacy.
      </footer>
    </div>

    <template id="message-template">
      <article class="message">
        <span class="message__role"></span>
        <p class="message__body"></p>
      </article>
    </template>

    <template id="typing-template">
      <article class="message bot">
        <span class="message__role">Bot</span>
        <span class="spinner" role="status" aria-label="Bot is thinking"></span>
      </article>
    </template>

    <script>
      (function () {
        const defaultPersona =
          'You are a thoughtful guide rooted in the values of privacy, open tooling, and gentle curiosity. Answer with clarity, warmth, and grounded imagination.';
        const personaInput = document.querySelector('#persona-input');
        const savePersonaButton = document.querySelector('#save-persona');
        const resetPersonaButton = document.querySelector('#reset-persona');
        const messagesList = document.querySelector('#messages');
        const chatForm = document.querySelector('#chat-form');
        const chatInput = document.querySelector('#chat-input');
        const sendButton = document.querySelector('#send-button');
        const messageTemplate = document.querySelector('#message-template');
        const typingTemplate = document.querySelector('#typing-template');

        if (!messagesList || !chatForm || !chatInput || !sendButton) {
          console.error('Chat UI failed to initialize: required elements are missing.');
          return;
        }

        const storageKey = 'codex-ii::persona';

        const state = {
          persona: loadPersona(),
          history: []
        };

        if (personaInput) {
          personaInput.value = state.persona;
        }

        appendMessage('system', 'System', 'Ready when you are. Your words stay on this machine.');

        chatForm.addEventListener('submit', function (event) {
          event.preventDefault();
          const prompt = chatInput.value.trim();
          if (!prompt) {
            return;
          }

          chatInput.value = '';
          chatInput.style.height = 'auto';

          appendMessage('user', 'You', prompt);
          state.history.push({ role: 'user', content: prompt });

          sendButton.disabled = true;
          const typingNode = createTypingNode();
          messagesList.appendChild(typingNode);
          scrollToBottom();

          fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              message: prompt,
              history: state.history,
              persona: state.persona
            })
          })
            .then(function (response) {
              if (!response.ok) {
                throw new Error('Server responded with ' + response.status);
              }
              return response.json();
            })
            .then(function (data) {
              const text = data && typeof data.reply === 'string' ? data.reply : '(No response payload received)';
              appendBotMessage(text);
            }, function (error) {
              const fallback =
                'Your bot endpoint is sleeping. Wake a local model and listen on /api/chat to chat for real.\n\n' +
                'Debug: ' + error.message;
              appendBotMessage(fallback);
            })
            .then(function () {
              if (typingNode && typingNode.parentNode) {
                typingNode.parentNode.removeChild(typingNode);
              }
              sendButton.disabled = false;
              scrollToBottom();
            });
        });

        chatInput.addEventListener('input', function () {
          chatInput.style.height = 'auto';
          chatInput.style.height = Math.min(chatInput.scrollHeight, 220) + 'px';
        });

        if (savePersonaButton) {
          savePersonaButton.addEventListener('click', function () {
            const value = personaInput ? personaInput.value.trim() : '';
            state.persona = value ? value : defaultPersona;
            if (personaInput) {
              personaInput.value = state.persona;
            }
            persistPersona();
            appendMessage('system', 'System', 'Persona updated. Future replies will follow your new guidance.');
            scrollToBottom();
          });
        }

        if (resetPersonaButton) {
          resetPersonaButton.addEventListener('click', function () {
            state.persona = defaultPersona;
            if (personaInput) {
              personaInput.value = defaultPersona;
            }
            persistPersona();
            appendMessage('system', 'System', 'Persona reset to default.');
            scrollToBottom();
          });
        }

        function appendBotMessage(text) {
          const safeText = typeof text === 'string' ? text : String(text);
          state.history.push({ role: 'assistant', content: safeText });
          appendMessage('bot', 'Bot', safeText);
        }

        function appendMessage(type, label, content) {
          const node = cloneMessageNode();
          if (type) {
            node.classList.add(type);
          }
          const roleElement = ensureChild(node, '.message__role', 'span', 'message__role');
          const bodyElement = ensureChild(node, '.message__body', 'p', 'message__body');
          roleElement.textContent = label;
          bodyElement.textContent = typeof content === 'string' ? content : String(content);
          messagesList.appendChild(node);
          scrollToBottom();
          return node;
        }

        function cloneMessageNode() {
          if (messageTemplate && messageTemplate.content && messageTemplate.content.firstElementChild) {
            return messageTemplate.content.firstElementChild.cloneNode(true);
          }
          const article = document.createElement('article');
          article.className = 'message';
          const roleSpan = document.createElement('span');
          roleSpan.className = 'message__role';
          const bodyParagraph = document.createElement('p');
          bodyParagraph.className = 'message__body';
          article.appendChild(roleSpan);
          article.appendChild(bodyParagraph);
          return article;
        }

        function createTypingNode() {
          if (typingTemplate && typingTemplate.content && typingTemplate.content.firstElementChild) {
            return typingTemplate.content.firstElementChild.cloneNode(true);
          }
          const article = document.createElement('article');
          article.className = 'message bot';
          const roleSpan = document.createElement('span');
          roleSpan.className = 'message__role';
          roleSpan.textContent = 'Bot';
          const spinner = document.createElement('span');
          spinner.className = 'spinner';
          spinner.setAttribute('role', 'status');
          spinner.setAttribute('aria-label', 'Bot is thinking');
          article.appendChild(roleSpan);
          article.appendChild(spinner);
          return article;
        }

        function ensureChild(parent, selector, tagName, className) {
          const existing = parent.querySelector(selector);
          if (existing) {
            return existing;
          }
          const element = document.createElement(tagName);
          element.className = className;
          parent.appendChild(element);
          return element;
        }

        function scrollToBottom() {
          const options = { top: messagesList.scrollHeight, behavior: 'smooth' };
          if (typeof messagesList.scrollTo === 'function') {
            try {
              messagesList.scrollTo(options);
              return;
            } catch (error) {
              // Older browsers may throw if smooth scrolling is unsupported.
            }
          }
          messagesList.scrollTop = messagesList.scrollHeight;
        }

        function loadPersona() {
          try {
            const stored = window.localStorage.getItem(storageKey);
            return stored ? stored : defaultPersona;
          } catch (error) {
            console.warn('Unable to read persona from storage', error);
            return defaultPersona;
          }
        }

        function persistPersona() {
          try {
            window.localStorage.setItem(storageKey, state.persona);
          } catch (error) {
            console.warn('Unable to store persona', error);
          }
        }
      })();
    </script>
  </body>
</html>
